# BarbeMCR's OpenCipher
An encryption/decryption application and API designed to obfuscate files and text

**_DISCLAIMER: BarbeMCR's OpenCipher is not meant for actual cryptographic purposes!_**

It is *not* built to protect sensitive information. Use it *only* for futile work.

While this application and its underlying API employ some security practices, you *shouldn't* trust either for securely encrypting things.

## BarbeMCR's OpenCipher API

To import the BarbeMCR's OpenCipher module, just put `import opencipher` in your script.

Here is some brief documentation of all "public" functions of the `opencipher` namespace:

`opencipher.encrypt(file, secret, multiple=False, intervals=False)`

Encrypt `file`, which must be a valid path to a file, using `secret`.

The encryption algorithm works as follows:
- the PRNG provided by `random` is initialized with a secure random seed (generated with `secrets`)
- the PRNG internal state is grabbed
- an encryption table is generated by randomly switching integers in range [0, 255], which represent all possible byte values
- if `multiple` is False or None, each byte in `file` is substituted using the encryption table and `file.lock` is written
- if `multiple` is True, a random `interval` in the range [1, 16] is chosen and each byte in an `interval`-sized chunk of `file` is substituted using the encryption table. Every `interval`, the encryption table is regenerated using the same method as above. If `intervals` is True, the `interval` is randomly set again
- the PRNG internal state is passed to `opencipher.encrypt_key` for encryption to `file.key` based on `secret`
- the encryption products (`file.lock` and `file.key`) are authenticated to `file.auth` using `opencipher.authenticate`
- `file.lock`, `file.key` and `file.auth` are hashed using `opencipher.hash` and the result is appended to `file.auth`

`opencipher.encrypt_string(string, secret, multiple=False, intervals=False)`

Encrypt `string`, which must be a valid `str`. Returns an encrypted copy of `string`.

The encryption algorithm works as follows:
- the PRNG is initialized using `secret` as the seed
- an encryption table is generated by randomly switching integers in range [0, 255], which represent all possible byte values
- if `multiple` is False or None, each byte in `string` is substituted using the encryption table and the resulting bytes are converted to `0x`-prefixed hexadecimal numbers and joined with `:`
- if `multiple` is True, a random `interval` in the range [1, 16] is chosen and each byte in an `interval`-sized chunk of `string` is substituted using the encryption table. Every `interval`, the encryption table is regenerated using the same method as above. If `intervals` is True, the `interval` is randomly set again. In both cases, the resulting bytes are converted to `0x`-prefixed hexadecimal numbers and joined with `:`

`opencipher.encrypt_key(raw_key, key, secret)`

Encrypt `raw_key`, which must be a `random` internal state or compatible, to `key`, which must be a valid output path.

The encryption algorithm works as follows:
- the PNRG is initialized using `secret` as the seed
- an encryption table is generated by randomly switching integers in range [0, 255], which represent all possible byte values
- each byte of the `raw_key` is substituted using the encryption table
- the encrypted key is pickled to `key`

`opencipher.authenticate(lock, key, auth, secret)`

Generate SHA-512 HMAC hexdigests for `lock` and `key` using `secret` and write them to `auth`, one after another. `lock` and `key` must be valid paths to the encrypted file and the encrypted key respectively, while `auth` must be a valid output path.

`opencipher.hash(lock, key, auth)`

Generate the SHA-512 hexhash for `lock`, `key` and `auth`, combined in a single `bytes` object. `lock`, `key` and `auth` must be valid paths to the encrypted file, the encrypted key and the digest store respectively. Returns the computed hexhash.

`opencipher.decrypt(file, key, auth, secret, multiple=False, intervals=False)`

Decrypt `file` using `key` and `secret`, after checking general validity with `auth`. `file`, `key` and `auth` must be valid paths to the encrypted file, the encrypted key and the digest and hash store respectively.

The decryption algorithm works as follows:
- `file`, `key` and `auth` are checked against corruption with `opencipher.check_hash`
- `file` and `key` are checked against tampering using `secret` with `opencipher.check_tampering`
- `key` is decrypted using `opencipher.decrypt_key`
- the PRNG internal state is restored using the decrypted key
- the file is decrypted using the same process as `opencipher.encrypt`, but the decrypted bytes are written using the table in reverse
- the decrypted file is written: if `file` was a `.*.lock` file, a corresponding `.*` file will be written

`opencipher.decrypt_string(enc_string, secret, multiple=False, intervals=False)`

Decrypt `enc_string`, which must be a valid `str`. Returns a decrypted copy of `enc_string`.

The decryption algorithm works as follows:
- the PRNG is initialized using `secret` as the seed
- the string is decrypted by first splitting it based on `:` and converting its parts back into integers, then applying the same process as `opencipher.encrypt_string`, but using the table in reverse

`opencipher.decrypt_key(key, secret)`

Decrypt `key`. Returns the decrypted `random` internal state.

The decryption algorithm works as follows:
- the PNRG is initialized using `secret` as the seed
- `key` is decrypted using the same process as `opencipher.encrypt_key`, but using the table in reverse
- the decrypted key is unpickled

`opencipher.check_tampering(lock, key, auth, secret)`

Check if `lock` and `key` have been tampered with. Returns True if they haven't, False otherwise.

The first 128 chars of `auth` hold the SHA-512 HMAC hexdigest of `lock`, computed using `secret`. The next 128 chars of `auth` hold the SHA-512 HMAC hexdigest of `key`, computed using `secret`.

Those digests are compared with the corresponding digests generated in real time from `lock` and `key` using `secret`.

`opencipher.check_hash(lock, key, auth)`

Check if `lock`, `key` and `auth` are corrupted. Returns True if they aren't, False otherwise.

The last 128 chars of `auth` hold the SHA-512 hexhash of `lock`, `key` and the first 256 chars of `auth`, when all combined in a single `bytes` object.

This hash is compared with the corresponding hash generated in real time from `lock`, `key` and `auth`.

---

While there are several other "private" `opencipher._*_ui` functions, those are only used for the application interface. You can ignore those when using the API.

You **should** always wrap `opencipher.*` functions in a try-except as follows:

```python
try:
    opencipher.<function>(*<arguments>)
    ...
except Exception:
    ...
```
